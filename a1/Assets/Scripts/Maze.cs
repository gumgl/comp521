//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using CustomExtensions;

public class Maze : MonoBehaviour
{
	public enum Direction{North, East, South, West};
	static Dictionary<Direction, Vector2> DirToPt = new Dictionary<Direction, Vector2>() {
		{Direction.North, Vector2.up},
		{Direction.East, Vector2.right},
		{Direction.South, -1 * Vector2.up},
		{Direction.West, -1 * Vector2.right}
	};
	
//	static Random RNG = new Random();

	int size = 30;
	public Block BlockPrefab;
	public Bullet BulletPrefab;
	public GameObject DoorPrefab;
	Block[,] grid = new Block[30,30];
	public Room[,] rooms = new Room[3,2];
	List<GameObject> doors = new List<GameObject>();
	List<Bullet> bullets = new List<Bullet>();
	List<int> roomSeq = new List<int>() {0,1,2};
	public Player player;
	public Text ui;
	public Text help;
	
	void Start () {
		//player = (Player) GameObject.Find("Player").gameObject;
		Generate();
	}

	void Update() {
		if (player.transform.position.z >= 90)
			ui.text = "You win!";
		
		if(Input.GetKeyDown(KeyCode.Space)) { // Display/hide help
			help.enabled = !help.enabled;
		}
		if (Input.GetKeyDown(KeyCode.Period) && player.bullet == null) { // Pick up
			//Debug.Log("Pick up");
			Bullet closest = null;
			float mindist = 0;
			foreach (Bullet bullet in bullets) {
				if (bullet != null) {
					float distance = Vector3.Distance(player.transform.position, bullet.transform.position);
					if (!bullet.used && distance < 3 && (closest == null || distance < mindist)) {
						closest = bullet;
						mindist = distance;
					}
				}
			}
			if (closest != null) { // ball is close enough to be picked up
				player.bullet = closest;
				closest.rigidbody.useGravity = false;
				closest.transform.parent = player.gameObject.transform;
				//iTween.MoveTo(closest.gameObject, iTween.Hash("position", new Vector3(0.12f, 0.28f, 1.17f), "time", 1.0f, "islocal",true));
				closest.transform.localPosition = new Vector3(0.12f, 0.28f, 1.17f);
				closest.collider.enabled = false;
				closest.rigidbody.velocity = Vector3.zero;
				closest.rigidbody.angularVelocity = Vector3.zero;
			}
		}
		if(Input.GetKeyDown(KeyCode.Comma) && player.bullet != null) { // Drop
			//Debug.Log("Drop");
			player.bullet.rigidbody.useGravity = true;
			player.bullet.transform.parent = gameObject.transform;
			player.bullet.collider.enabled = true;
			player.bullet = null;
		}
		if(Input.GetMouseButtonDown(0) && player.bullet != null) { // Shooting
			//Debug.Log("Shoot");
			player.bullet.rigidbody.useGravity = true;
			player.bullet.transform.parent = gameObject.transform;
			player.bullet.collider.enabled = true;
			player.bullet.used = true;
			player.bullet.rigidbody.AddForce(player.transform.forward*1000);
			player.bullet = null;
		}
	}

	void Generate() {
		//entry = Random.Range (0,2);
		//roomSeq[2] = Random.Range(0,2);
		roomSeq.Shuffle();

		SpawnBlocks();

		for (int section = 0; section <3; section ++){
			for (int level = 0; level <2; level ++) {
				Vector2 boundMin = new Vector2(10*section, 15*level);
				Vector2 boundMax = new Vector2(10*(section+1), 15*(level+1));
				rooms[section, level] = MakeRoom(section, level, boundMin, boundMax);
				Room room = rooms[section, level];

				// Make a maze below
				PrimsAlgRandom(boundMin, new Vector2(boundMax.x, room.pos.y));

				// Make a maze above
				PrimsAlgRandom(new Vector2(boundMin.x, room.pos.y), boundMax);
			}
		}
		List<Bullet.Color> doorColors = new List<Bullet.Color>();
		foreach(Bullet.Color c in System.Enum.GetValues(typeof(Bullet.Color)))
			doorColors.Add(c);
		// Connect the sections/levels
		for (int section = 0; section <3; section ++){
			for (int level = 0; level <2; level ++) {
				Vector2 boundMin = new Vector2(10*section, 15*level);
				Vector2 boundMax = new Vector2(10*(section+1), 15*(level+1));
				Room room = rooms[section,level];

				// Make an entrance to the room
				Block entryBlockIn = PtToBlock(room.pos - Vector2.up);
				entryBlockIn.removeWall(Direction.South);
				Block entryBlockOut = PtToBlock(room.pos - 2 * Vector2.up);
				entryBlockOut.removeWall(Direction.North);

				// Make an exit to the room
				if (level == 0 || section == roomSeq[2]) {
					Block exitBlockIn = PtToBlock(room.pos + Vector2.up);
					exitBlockIn.removeWall(Direction.North);
					Block exitBlockOut = PtToBlock(room.pos + 2 * Vector2.up);
					exitBlockOut.removeWall(Direction.South);

					// Spawn door
					int colorID = Random.Range (0,doorColors.Count);
					room.doorColor = doorColors[colorID];
					doorColors.RemoveAt(colorID);
					GameObject door = (GameObject) Instantiate(DoorPrefab, new Vector3(0, 0, 0), Quaternion.identity);
					door.transform.parent = gameObject.transform;
					door.transform.localScale = new Vector3(1,1,0.2f);
					door.transform.localPosition = new Vector3(room.pos.x, 0, room.pos.y+2) + new Vector3(0.5f, 0.5f, 0.0f);
					door.renderer.material.color = Bullet.ColorOf[room.doorColor];
					doors.Add(door);
					room.door = door;
				}
				if (level == 0) { // Primary
					// Connect each level within a section by cutting a hole to the top
					Block passageIn = PtToBlock (new Vector2(Random.Range(boundMin.x, boundMax.x), boundMax.y-1));
					passageIn.removeWall(Direction.North);
					Block passageOut = PtToBlock (passageIn.coord + Vector2.up);
					passageOut.removeWall(Direction.South);

					// Make entrance to maze
//					if (section == entry) {
//						Block mazeEntrance = PtToBlock (new Vector2(Random.Range(boundMin.x,boundMax.x), 0));
//						mazeEntrance.removeWall(Direction.South);
//					}

					
					// Connect each section before primary rooms
					if (section < 2) {
						int y = System.Math.Min((int)room.pos.y, (int)rooms[section+1,0].pos.y);
						//Debug.Log (y);
						Block wayIn = PtToBlock (new Vector2(boundMax.x-1, Random.Range(boundMin.y, y)));
						wayIn.removeWall(Direction.East);
						Block wayOut = PtToBlock (wayIn.coord + Vector2.right);
						wayOut.removeWall(Direction.West);
					}
				} else { // Secondary
					
					// Connect each section after secondary rooms
					if (section < 2) {
						int y = System.Math.Max ((int)room.pos.y +1, (int)rooms[section+1,1].pos.y + 1);
						//Debug.Log (y);
						Block passageIn = PtToBlock (new Vector2(boundMax.x-1, Random.Range(y, boundMax.y)));
						passageIn.removeWall(Direction.East);
						Block passageOut = PtToBlock (passageIn.coord + Vector2.right);
						passageOut.removeWall(Direction.West);
					}

					// Drop a bullet in room
//					(Block) Instantiate(BulletPrefab, new Vector3(0, 0, 0), Quaternion.identity);
//								grid [x, y].transform.parent = gameObject.transform;
//								grid [x, y].transform.localScale = new Vector3(1,1,1);
//								grid [x, y].transform.localPosition = new Vector3(x,0,y);
//								grid [x, y].coord = new Vector2(x,y);
				}
			}
		}
		
		// Make exit out of maze
		Block mazeExit = PtToBlock (new Vector2(Random.Range(0,30), 29));
		mazeExit.removeWall(Direction.North);
		// Make entrance into maze
		Block mazeEntrance = PtToBlock (new Vector2(Random.Range(0,30), 0));
		mazeEntrance.removeWall(Direction.South);
		
		// Make exit out of 1 secondary room
//		Block finishBlockIn = PtToBlock(rooms[exit, 1].pos + Vector2.up);
//		finishBlockIn.removeWall(Direction.North);
//		Block finishBlockOut = PtToBlock(rooms[exit, 1].pos + 2 * Vector2.up);
//		finishBlockOut.removeWall(Direction.South);
		
		// Spawn a bullet in start room with color of first room
		SpawnBullet (new Vector2(Random.Range (1,29), -1), rooms[roomSeq[0],0].doorColor);
		// Spawn a bullet in 1st room with color of 2nd room
		SpawnBullet (rooms[roomSeq[0],1].pos, rooms[roomSeq[1],0].doorColor);
		// Spawn a bullet in 2nd room with color of last room
		SpawnBullet (rooms[roomSeq[1],1].pos, rooms[roomSeq[2],0].doorColor);
//		// Spawn a bullet in finish room, with the color of the door
		SpawnBullet (rooms[roomSeq[2],1].pos, rooms[roomSeq[2],1].doorColor);

	}

	void SpawnBlocks() {
		// Generate a grid full of blocks
		for (int x=0; x<30; x++) {
			for (int y=0; y<30; y++) {
				grid [x, y] = (Block) Instantiate(BlockPrefab, new Vector3(0, 0, 0), Quaternion.identity);
				grid [x, y].transform.parent = gameObject.transform;
				grid [x, y].transform.localScale = new Vector3(1,1,1);
				grid [x, y].transform.localPosition = new Vector3(x,0,y);
				grid [x, y].coord = new Vector2(x,y);
			}
		}
	}
	void SpawnBullet(Vector2 pos, Bullet.Color color) {
		Bullet bullet = (Bullet) Instantiate(BulletPrefab, new Vector3(0, 0, 0), Quaternion.identity);
		bullet.color = color;
		bullet.transform.parent = gameObject.transform;
		//bullet.transform.localScale = new Vector3(1,1,1);
		bullet.transform.localPosition = new Vector3(pos.x, 0.5f, pos.y);
		bullet.renderer.material.color = Bullet.ColorOf[color];
		bullet.maze = this;
		bullets.Add(bullet);
	}
	// Needs at least one cell to be not visited, otherwise loops forever
	void PrimsAlgRandom(Vector2 boundMin, Vector2 boundMax) {
		Block start;
		int max = 0; // safeguard against infinite loop
		do {
			start = PtToBlock(new Vector2(Random.Range(boundMin.x, boundMax.x), Random.Range(boundMin.y, boundMax.y)));
			max++;
		} while (start.visited > 0 && max < 1000000);
		PrimsAlg(start, boundMin, boundMax);
	}
	
	void PrimsAlg(Block start, Vector2 boundMin, Vector2 boundMax) {
		List<Block> frontier = new List<Block>();
		frontier.Add (start);
		
		while (frontier.Count > 0) {
			// Choose one random block from frontier
			//visit.OrderBy(a => Random.Range(0, System.Int32.MaxValue));
			int blockID = Random.Range(0, frontier.Count);
			Block block = frontier[blockID];
			frontier.RemoveAt(blockID);
			block.visited ++;
			
			// Compute all possible directions
			List<Direction> dirs = new List<Direction>();
			foreach (Direction dir in System.Enum.GetValues(typeof(Direction))) {
				Vector2 newPos = block.coord + DirToPt[dir];
				if (InRange (newPos, boundMin, boundMax)) {
					Block newBlock = PtToBlock(newPos);
					if (newBlock.visited < 1) {
						dirs.Add (dir);
					}
					
				}
			}
			if (dirs.Count > 0) { // Follow one
				//				Debug.Log ("breaking the wall", block);
				//				int dirID = ;
				Direction dir = dirs[Random.Range(0, dirs.Count)];
				//				dirs.RemoveAt(dirID);
				
				Vector2 newPos = block.coord + DirToPt[dir];
				Block newBlock = PtToBlock(newPos);
				
				Destroy (block.wallObjects[dir]);
				block.wallBool[dir] = false;
				
				Destroy (newBlock.wallObjects[ReverseDirection(dir)]);
				newBlock.wallBool[dir] = false;
				
				newBlock.visited ++;
				
				frontier.Add(newBlock);
			} 
			if (dirs.Count > 1){
				frontier.Add(block);
			}
		
		}
		// Add the others to visit later
		/*foreach(Direction dir in dirs) {
				visit.Add (PtToBlock(block.coord + DirToPt[dir]));*/
	}

	Room MakeRoom(int section, int level,Vector2 boundMin,Vector2 boundMax) {
		Vector2 pos;
		/*switch(section * 3 + level) {
		case 0*3+0: // A primary
			pos = new Vector2(Random.Range (1,9), Random.Range (1,14));
			break;
		case 0*3+1: // A secondary
			pos = new Vector2(Random.Range (1,9), Random.Range (1,14));
			break;
		case 1*3+0: // B primary
			pos = new Vector2(Random.Range (1,9), Random.Range (1,14));
			break;
		case 1*3+1: // B secondary
			pos = new Vector2(Random.Range (1,9), Random.Range (1,14));
			break;
		case 2*3+0: // C primary
			pos = new Vector2(Random.Range (1,9), Random.Range (1,14));
			break;
		case 2*3+1: // C secondary
			pos = new Vector2(Random.Range (1,9), Random.Range (1,14));
			break;
		}*/
		pos = new Vector2((int)Random.Range(boundMin.x+2, boundMax.x-2), (int)Random.Range(boundMin.y+2, boundMax.y-2));
		 // delete all wall within it
//		Debug.Log ("min, max, pos");
//		Debug.Log (boundMin);
//		Debug.Log (boundMax);
//		Debug.Log (pos);
		for (int dx = -1; dx <= 1; dx ++){ // for all 9 blocks of room
			for (int dy = -1; dy <= 1; dy ++) {
				Vector2 dpt = new Vector2(dx, dy);
				Block block = PtToBlock(pos + dpt);
				block.visited ++;

				if (dx < 1)
					block.removeWall (Direction.East);
				if (dx > -1)
					block.removeWall (Direction.West);
				if (dy < 1)
					block.removeWall (Direction.North);
				if (dy > -1)
					block.removeWall (Direction.South);
			}
		}
		return new Room(pos);
	}

	Block PtToBlock(Vector2 point) {
		return grid[(int)point.x, (int)point.y];
	}
	// return whether point is in the square range defined by min inclusive, max exclusive (too keep with Unity's standards)
	static bool InRange(Vector2 point, Vector2 min, Vector2 max) {
		return (point.x >= min.x
		        && point.x < max.x
		        && point.y >= min.y
		        && point.y < max.y);
	}
	static Direction ReverseDirection (Direction dir)
	{
		if(dir == Direction.North)
			dir = Direction.South;
		else if(dir == Direction.South)
			dir = Direction.North;
		else if(dir == Direction.East)
			dir = Direction.West;
		else if(dir == Direction.West)
			dir = Direction.East;
		
		return dir;     
	}
	
}